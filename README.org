
#+DRAWERS: HIDDEN STATE
#+PROPERTY: header-args: lang           :varname value
#+PROPERTY: header-args:C++             :results output  :flags -std=c++17 -Wall --pedantic -Werror

* C++
Sources:
- The Cherno(YTube) c++ series
- Programming principles and practice in C++ book by Dr. Stroustrup

*** Table of contents
:PROPERTIES:
:TOC:      :include siblings :depth 1
:END:
:CONTENTS:
- [[#notes-about-compiling-and-linking][Notes about Compiling and linking]]
- [[#pointer][Pointer]]
- [[#references][References]]
- [[#class-vs-structs][Class vs Structs]]
- [[#class-defining-methods-outside-the-classes][Class: Defining methods outside the classes]]
- [[#class-example-console-log-class][Class Example: Console Log class]]
- [[#static-keyword-for-file-level][Static Keyword for file level]]
- [[#static-for-class-and-structs][Static for class and structs]]
- [[#enums][Enums]]
- [[#update-log-class-to-use-enum][Update: Log Class to use enum]]
:END:

*** Notes about Compiling and linking
**** preprocessing, compiling and linking and assembly generation commands
Compille
#+begin_src sh
  g++ -c temp.cpp // only compiles and generates obj files
  g++ -c impl.cpp // generates obj file doesnot require main func

  g++ temp.o impl.o -o ./temp // links the files
  g++ temp.cpp impl.cpp -o ./temp // Same results compilation and links happens together

  g++ -E temp.cpp // outputs temp.cpp after pre-processing
  g++ -E -P temp.cpp // Hides pre-processor comments

  g++ -S temp.cpp // outputs the assembly instructions
#+end_src
**** Compiling
- Take text files and create intermediate files called object files .o extension
- STEP1: Preprocessor statements are evaluated first (this includes the #include or #define etc)
- AST Generation: The compiler parses the english like source into tokens and generates a tree like structured that can be easily traversed later for evaluation. This tree is called abstract syntax tree.
- Finally with AST, compiler generates code (machine code) representing both instructions and data that CPU can execute

***** Translational Units and obj files
- A program can be split intro multiple cpp files
- When compiled every cpp file will always be compiled into individual obj files.
- This individual obj files are called transational units
- Files generally have no meaning in the implementation of compiler
- They are just a way for us to visually/logically seperate code for us to be managable
- This means we can feed files with any extension and compiler can read it
- We have to explicitly specify rule for custom extension for compiler to either treat it like .cpp or .c or .h file.
- .h .cpp and .c extension are pre-registered built-in. They are not so special in themselves

- This is important because we can include multiple cpp files in a single cpp file and compile it to result in single translation units.
- A translation unit doesenot necessarily equal to a translational units
- However note that every cpp file will produce a obj files

***** Includes  and define statements
- When you #include you specify a file. Compiler goes to the file and copy paste its content in place of #include statements. Its that simple.

  Lets declare a header file "test.h"
  #+begin_export C
  }
  #+end_export

  Then a main c file:
  #+begin_src C++ :results output :exports both
    int main(){
       return 0;
   #include "test.h"
  #+end_src

  This will output:
  #+begin_src C++ :results output :exports both
     int main(){
        return 0;
    }
  #+end_src

  This copy pasting also applies to #define statements. Compiler just do a search replace on the source file.

**** Linking
- Links the objs file generated when compiling
- Combines to build an executable with and entry point
- Complains if main not found. Entry point can be anything main is just convention
- Also does the checking for included or prototypes definitions which compiler doesnot require
- When the exact signature matching find fails while including other files. Generates unrecognized external symbol
- Similarly Linker skips compilation if the imported stuff is never used in current file.
- However, linker complains about func defined/declared inside even tho its not used (unless declared static)
   (I couldnot replicate this behaviour with g++ sadly)

- Common linking error: Duplicate definitions
- This generally happens if you include a file with definition and also define it in current file
- Easy fix Use header file only for prototype and preprocessing and never include cpp files
- When including cpp files confirm/check know what you're doing also use static whenever possible to prevent this

*** Pointer
An integer storing memory address

Example to show types dont matter, just for compiler and ours sake.
#+begin_src C++ :includes <iostream> :main no
  int main()
  {
    void* invalid_ptr = 0;
    void* nvalid_ptr = NULL; // same as 0
    void* invlid_ptr = nullptr;

    // getting a pointer
    int var = 8;
    void* ptr = &var;
    return 0;
  }
#+end_src

*** References
Pretty much the same under hood. Syntactic sugar over pointer

pointer are a entirely new variable (exists in memory thus has its own addr). This variable just happen to store 8 byte (integer) representing other addr.

Refrences only can be made on top of existing var. They are not present in the memory and take no space. Its impossible to create a reference to NULL.


// ampersand (&) beside a variable is a "addresof" operator
#+begin_src C++
  int* b = &a;
#+end_src

// ampersand as part of type is a reference
#+begin_src C++
  int& b = a;
#+end_src

Reference is not really variable, exists only in source code. It is an alias.
This can be somewhat linked to this code snippet
#+begin_src C++ :results output :includes <iostream> :exports both
  int a = 3;
  int b = a;
  int& c = a;

  std::cout << "A: "<< &a << "\nB: " << &b << "\nC: " << &c;
#+end_src

#+RESULTS:
: A: 0x7ffc0f9125d8
: B: 0x7ffc0f9125dc
: C: 0x7ffc0f9125d8

In python the first two line would have produced the desired output.
#+begin_src python :results output :exports both
  a = 3
  b = a
  print("A:", hex(id(a)), "\nB: ", hex(id(b)))
#+end_src

#+RESULTS:
: A: 0x955e80
: B:  0x955e80

Well in C++ things are different and you have to use Reference

Note: This is where the similarity in Python ends, while python just aliases the variable to avoid creating objects in memory. C++ does much more than that


Emulating pointers:

#+begin_src C++ :includes <iostream> :main no :results output :exports both
  void increment_int(int* a){
  // Note: (*a)++ and not *a++ dereference then increment no reference an incremented address
     (*a)++;
  }

  int main(){
    int a = 10;
    int* b = &a;
    increment_int(b);
    std::cout << "A: " << a;
    return 0;
  }
#+end_src

#+RESULTS:
: A: 10

This is standard syntax used when trying to emulate a pass by reference in C. You dont want to pass the actual value 10 but you want to be able to modify it. Passing address of 10 and putting anything in that address is the way

#+begin_src C++ :main no :includes <iostream> :results output :exports both
  void increment_int(int& i){
    i++;
  }

  int main(){
    int a = 10;
    increment_int(a);
    std::cout << "A: " << a;
    return 0;
  }
#+end_src

#+RESULTS:
: A: 11


Losing all that cruft looks nice and it makes perfect sense for a compiler either ways.
The real cost however is Magic. You are no longer passing the the value 10 to function tho it may look like it. The compiler looks at both the function call and function definition and actually makes the translation.

#+begin_src C++
  // func def
  void call_func(int num){}

  // call to function
  int a = 10;
  call_func(a) // --> call_func(10) --> num = 10

  void call_func2(int& num){}
  int a = 10;
  call_func(a) // --> call_func2(&a)
#+end_src

SUMMARY

Pointers do too much.

- References acts as immutable pointer that are automatically dereferenced
- Subset of pointer features to use reference in substitute

  - passing large objects to function arguments
  - Passing things to function for the function to modify the underlying value


DIFFERENCE WITH POINTERS (from bjarne c++ programming priciple and practice book)

- Assignment to a pointer changes the pointer's value (not the pointed-to value).

- To get a pointer you generally need to use new or &.

- To access an object pointed to by a pointer you use * or [].

 - Assignment to a reference changes the value of the object referred to (not
the reference itself).

- You cannot make a reference refer to a different object after initialization.

- Assignment of references does deep copy (assigns to the referred-to object); assignment of pointers does not (assigns to the pointer object itself).

- Beware of null pointers.

*** Class vs Structs
Structs and class in C++ have very little difference. Struct is only for backward compatible reason.

In class the fields and methods declared inside are private unless explicitly made public using the said keyword.
So yeah, the difference is just the private: keyword.

You can go to a C struct replace the struct word with class and add public keyword and boom its a valid c++ and you can replace any valid C++ class with struct and adjust the private keyword and there you go a valid c++ code.
#+begin_src C++
  class Test{
    int priv_a, priv_b;
    void priv_func();
    }

  struct Test{
    private:
      int priv_a, priv_b;
      void priv_func();
}
#+end_src
Both are equivalent. You can literally do a whole class hierarchy and inheritance just using struct heck you can make a struct inherit from class.

So all in all it seems like Bjarne designed classes in C++ then just renamed it to struct and made member public by default thats it

**** Semantic Difference
This is the difference we really care about. Since a whole culture of programmers evolved using struct in C. There are some preconceived roles of structs and class.

- Using class just for storing 2-3 variables kinda seems odd to some.
- So for simple non-complicated stuff having few member and trivial little functions use struct
- For more complicated use, having tons of members, using a constructor, non trivial methods, inheritance and hierarchy use class, structs will just feel out of place

 Again no difference to the compiler just semantic notion and popular convention that's it.

*** Class: Defining methods outside the classes
***** Includes
#+name: DMOCIncludes
#+begin_src C++
  #include <iostream>
#+end_src

***** Addition class definition
#+name: DMOCAdditionClass
#+begin_src C++
  class Addition{
  private:
    int a, b, sum;
  public:
    void get(int x, int y);
    void process();
    void print();
  };

  void Addition::get(int x, int y){
    a = x;
    b = y;
  }

  void Addition::process(){
    sum = a+b;
  }

  void Addition::print(){
    std::cout << "Sum of the " << a << " and " << b << " is " << sum << std::endl;
  }
#+end_src

***** Main loop
#+name: DMOCMain
#+begin_src C++
  int main(){
    Addition A;
    A.get(10, 20);
    A.process();
    A.print();
    return 0;
    }
#+end_src

***** Program
DMOC refers to shortform of this problem: Declaring method outside class
#+begin_src C++ :results output :main no :exports both :tangle ~/dev/csit/class_method_define_outside.cpp :noweb yes
  <<DMOCIncludes>>

  <<DMOCAdditionClass>>

  <<DMOCMain>>

#+end_src

#+RESULTS:
: Sum of the 10 and 20 is 30

*** Class Example: Console Log class
**** Designing API

#+name: LogMain
#+begin_src C++
  int main(){
      Log log;
      log.Info("Setting level to Error");
      log.SetLevel(log.LogLevelError);
      log.Warn("This is warning");
      log.Error("This is error");


      log.SetLevel(log.LogLevelInfo);
      log.Info("Setting level to Info");
      log.Error("This is error");
      log.Warn("This is warning");
      log.Info("This is info");

      return 0;
    }
#+end_src

#+RESULTS: Main

**** Make class
#+name: LogClass
#+begin_src C++
  class Log{
    public:
      const int LogLevelError = 0;
      const int LogLevelWarning = 1;
      const int LogLevelInfo = 2;

    private:
      int m_logLevel = 2;

    public:
      void SetLevel(int level){
        m_logLevel = level;
     }
      void Error(const char* message){
        if(m_logLevel >= LogLevelError)
         std::cout << "[Error]: " << message << std::endl;
      }
      void Warn(const char* message){
        if(m_logLevel >= LogLevelWarning)
         std::cout << "[Warn]: " << message << std::endl;
      }
      void Info(const char* message){
        if(m_logLevel >= LogLevelInfo)
         std::cout << "[Info]: " << message << std::endl;
      }
    };
#+end_src

**** Includes
#+name: LogInclude
#+begin_src C++
  #include <iostream>
#+end_src

**** Combine
#+begin_src C++ :main no :noweb yes :exports both :tangle ~/dev/csit/class_log_example.cpp :results output
  <<LogInclude>>

  <<LogClass>>

  <<LogMain>>

#+end_src

#+RESULTS:
: [Info]: Setting level to Error
: [Error]: This is error
: [Info]: Setting level to Info
: [Error]: This is error
: [Warn]: This is warning
: [Info]: This is info

*** Static Keyword for file level
- A keyword that limits the scope of a variable or function within a translation unit
- Very useful for defensive progamming.
- Recommended to use s underscore (s_) convention
- Opposite of extern where a var is only initiliazed in a file and its declaration is on another file

*** Static for class and structs
- declaring a variable static inside a class means the variable will be shared across all the instances of the class.
- Its not created everytime an object is instantiated. If one instance changes this var it is reflected across all instances
#+begin_src C++ :results output :exports both :includes <iostream> :tangle ~/dev/csit/class_static_variables_intro.cpp
  class Test{
    public:
    static int y;
    static int x;

    public:
    void print_x_y(){
      std::cout << x << ", " << y <<std::endl;
      }
    };

  int Test::x;
  int Test::y;

  int main(){
    Test t = Test();
    t.x = 3;
    t.y = 4;
    t.print_x_y();

    Test t1 = Test();
    t1.x = 9;
    t1.y = 8;
    t.print_x_y();

    Test::x = 100;
    Test::y = 200;

    t.print_x_y();
    t1.print_x_y();
  }
#+end_src

#+RESULTS:
: 3, 4
: 9, 8
: 100, 200
: 100, 200

- We need to actually define x and y again outside for linker to link it.
- At this point its kinda ovious that we're modifying a single instace of x and y
- They are similar to being inside the namespace of Test, it does have additional class benefits of being private public etc.
- Very useful for sharing data across class instances instead of creating global variables


- Static method is similar where you get to access the function independent of instance. Conversely this means you cannot write instance dependent code inside the class
  This is similar to @staticmethod decorator in python.
  #+begin_src C++ :results output :exports both :includes <iostream> :tangle ~/dev/csit/class_static_function_intro.cpp
      class Test{
        public:
        static int y;
        static int x;

        public:
        static void print_x_y(){
          std::cout << x << ", " << y <<std::endl;
          }
        };

      int Test::x;
      int Test::y;

      int main(){
        Test::x = 10;
        Test::y = 10;

        Test t = Test();
        t.print_x_y();
        Test::print_x_y();

        t.x = 100;
        t.y = 200;

        t.print_x_y();
        Test::print_x_y();
    }
  #+end_src

  #+RESULTS:
  : 10, 10
  : 10, 10
  : 100, 200
  : 100, 200

  - Both call to print are same but since print doesnot receive the instance it's called from it is recommended to call it directly from Class name instead to make our intent explicit

  #+RESULTS:
  : 10, 10
  : 10, 10

*** Enums
- Giving name for group of integer to make it more readable/organized.
#+begin_src C++ :results output :exports both :includes <iostream> :tangle ~/dev/csit/enum_intro.cpp

  enum TrafficLight{
    RED, YELLOW, GREEN,
  };

  enum Grade : unsigned int{
    A_PLUS=90, A=80, B_PLUS=70, B=60,
  };

  int main(){
    int currentLight = RED;
    if (currentLight < 2){
      std::cout << "STOP" << std::endl;
    }
    Grade level = A_PLUS;
    if (level > A){
      std::cout << "You are an A Plus level student" << std::endl;
    }
    return 0;
  }
#+end_src

#+RESULTS:
: STOP
: You are an A Plus level student

- We can specify the type of enum as interger variations (signed/unsigned char/int) but not float or double since it must be integer
- Vars inside enums are basically a global variable not connected to the namespace so declare them inside a scoped entity like class.
- The holder (currentLight or level) can both be defined as int or name of Enum.
- Declaring using the name of enum (syntactically) limits its assignation to the value other than members of enum.

*** Update: Log Class to use enum
**** The class
#+name: LogClassEnum
#+begin_src C++
  class Log{
    public:
      enum Level: unsigned int{
        LevelError = 0, LevelWarning = 1, LevelInfo = 2
      };

    private:
      Level m_logLevel = LevelInfo;

    public:
      void SetLevel(Level level){
        m_logLevel = level;
     }
      void Error(const char* message){
        if(m_logLevel >= LevelError)
         std::cout << "[Error]: " << message << std::endl;
      }
      void Warn(const char* message){
        if(m_logLevel >= LevelWarning)
         std::cout << "[Warn]: " << message << std::endl;
      }
      void Info(const char* message){
        if(m_logLevel >= LevelInfo)
         std::cout << "[Info]: " << message << std::endl;
      }
    };
#+end_src

#+RESULTS: LogClassEnum

**** Main func
#+name: LogMainEnum
#+begin_src C++
  int main(){
      Log log;
      log.Info("Setting level to Error");
      log.SetLevel(Log::LevelError);
      log.Warn("This is warning");
      log.Error("This is error");


      log.SetLevel(Log::LevelInfo);
      log.Info("Setting level to Info");
      log.Error("This is error");
      log.Warn("This is warning");
      log.Info("This is info");

      return 0;
    }
#+end_src

**** Includes
#+name: LogIncludeEnum
#+begin_src C++
  #include <iostream>
#+end_src

**** Combine
#+begin_src C++ :main no :noweb yes :exports both :tangle ~/dev/csit/class_log_example.cpp :results output
  <<LogIncludeEnum>>

  <<LogClassEnum>>

  <<LogMainEnum>>

#+end_src

#+RESULTS:
: [Info]: Setting level to Error
: [Error]: This is error
: [Info]: Setting level to Info
: [Error]: This is error
: [Warn]: This is warning
: [Info]: This is info
