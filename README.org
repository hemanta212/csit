
#+DRAWERS: HIDDEN STATE
#+PROPERTY: header-args: lang           :varname value
#+PROPERTY: header-args:C++             :results output  :flags -std=c++17 -Wall --pedantic -Werror

** C++
Sources:
- The Cherno(YTube) c++ series
- Programming principles and practice in C++ book by Dr. Stroustrup

*** Table of contents
:PROPERTIES:
:TOC:      :include siblings :depth 1
:END:
:CONTENTS:
- [[#notes-about-compiling-and-linking][Notes about Compiling and linking]]
- [[#pointer][Pointer]]
- [[#references][References]]
- [[#class-vs-structs][Class vs Structs]]
- [[#class-defining-methods-outside-the-classes][Class: Defining methods outside the classes]]
- [[#class-example-console-log-class][Class Example: Console Log class]]
- [[#static-keyword-for-file-level][Static Keyword for file level]]
- [[#static-for-class-and-structs][Static for class and structs]]
- [[#enums][Enums]]
- [[#update-log-class-to-use-enum][Update: Log Class to use enum]]
- [[#constructors][Constructors]]
- [[#destructors][Destructors]]
- [[#inheritance][Inheritance]]
- [[#virtual-function][Virtual Function]]
- [[#interfaces-pure-virtual-functions][Interfaces (Pure virtual functions)]]
- [[#arrays][Arrays]]
- [[#strings-in-c][Strings in C++]]
- [[#string-literals][String literals]]
- [[#const-keyword][Const keyword]]
- [[#mutable][Mutable]]
- [[#member-initializer-list][Member Initializer List]]
- [[#ternary-operators][Ternary Operators]]
- [[#createinstantiate-objects][Create/instantiate objects]]
- [[#the-new-keyword][The New Keyword]]
- [[#implicit-conversion-and-explicit-keyword][Implicit conversion and Explicit keyword]]
- [[#operator-and-operator-overloading][Operator and Operator Overloading]]
- [[#this-keyword][this keyword]]
- [[#object-lifetime-stackscope-lifetimes][Object Lifetime (Stack/Scope Lifetimes)]]
- [[#smart-pointers][Smart Pointers]]
- [[#templates][Templates]]
- [[#function-pointers][Function pointers]]
- [[#virtual-destructors][Virtual Destructors]]
- [[#exception-handling][Exception Handling]]
- [[#file-handling][File Handling]]
:END:

*** Notes about Compiling and linking
**** preprocessing, compiling and linking and assembly generation commands
Compille
#+begin_src sh
  g++ -c temp.cpp # only compiles and generates obj files
  g++ -c impl.cpp # generates obj file doesnot require main func

  g++ temp.o impl.o -o ./temp # links the files
  g++ temp.cpp impl.cpp -o ./temp # Same results compilation and links happens together

  g++ -E temp.cpp # outputs temp.cpp after pre-processing
  g++ -E -P temp.cpp # Hides pre-processor comments

  g++ -S temp.cpp # outputs the assembly instructions
#+end_src
**** Compiling
- Take text files and create intermediate files called object files .o extension
- STEP1: Preprocessor statements are evaluated first (this includes the #include or #define etc)
- AST Generation: The compiler parses the english like source into tokens and generates a tree like structured that can be easily traversed later for evaluation. This tree is called abstract syntax tree.
- Finally with AST, compiler generates code (machine code) representing both instructions and data that CPU can execute

***** Translational Units and obj files
- A program can be split intro multiple cpp files
- When compiled every cpp file will always be compiled into individual obj files.
- This individual obj files are called transational units
- Files generally have no meaning in the implementation of compiler
- They are just a way for us to visually/logically seperate code for us to be managable
- This means we can feed files with any extension and compiler can read it
- We have to explicitly specify rule for custom extension for compiler to either treat it like .cpp or .c or .h file.
- .h .cpp and .c extension are pre-registered built-in. They are not so special in themselves

- This is important because we can include multiple cpp files in a single cpp file and compile it to result in single translation units.
- A translation unit doesenot necessarily equal to a translational units
- However note that every cpp file will produce a obj files

***** Includes  and define statements
- When you #include you specify a file. Compiler goes to the file and copy paste its content in place of #include statements. Its that simple.

  Lets declare a header file "test.h"
  #+begin_src C
  }
  #+end_src

  Then a main c file:
  #+begin_src C++ :results output :exports both
    int main(){
       return 0;
   #include "test.h"
  #+end_src

  This will output:
  #+begin_src C++ :results output :exports both
     int main(){
        return 0;
    }
  #+end_src

  This copy pasting also applies to #define statements. Compiler just do a search replace on the source file.

**** Linking
- Links the objs file generated when compiling
- Combines to build an executable with and entry point
- Complains if main not found. Entry point can be anything main is just convention
- Also does the checking for included or prototypes definitions which compiler doesnot require
- When the exact signature matching find fails while including other files. Generates unrecognized external symbol
- Similarly Linker skips compilation if the imported stuff is never used in current file.
- However, linker complains about func defined/declared inside even tho its not used (unless declared static)
   (I couldnot replicate this behaviour with g++ sadly)

- Common linking error: Duplicate definitions
- This generally happens if you include a file with definition and also define it in current file
- Easy fix Use header file only for prototype and preprocessing and never include cpp files
- When including cpp files confirm/check know what you're doing also use static whenever possible to prevent this

*** Pointer
An integer storing memory address

Example to show types dont matter, just for compiler and ours sake.
#+begin_src C++ :includes <iostream> :main no
  int main()
  {
    void* invalid_ptr = 0;
    void* nvalid_ptr = NULL; // same as 0
    void* invlid_ptr = nullptr;

    // getting a pointer
    int var = 8;
    void* ptr = &var;
    return 0;
  }
#+end_src

*** References
Pretty much the same under hood. Syntactic sugar over pointer

pointer are a entirely new variable (exists in memory thus has its own addr). This variable just happen to store 8 byte (integer) representing other addr.

Refrences only can be made on top of existing var. They are not present in the memory and take no space. Its impossible to create a reference to NULL.


- ampersand (&) beside a variable is a "addresof" operator
#+begin_src C++
  int* b = &a;
#+end_src

- ampersand as part of type is a reference
#+begin_src C++
  int& b = a;
#+end_src

Reference is not really variable, exists only in source code. It is an alias.
This can be somewhat linked to this code snippet
#+begin_src C++ :results output :includes <iostream> :exports both
  int a = 3;
  int b = a;
  int& c = a;

  std::cout << "A: "<< &a << "\nB: " << &b << "\nC: " << &c;
#+end_src

#+RESULTS:
: A: 0x7ffc0f9125d8
: B: 0x7ffc0f9125dc
: C: 0x7ffc0f9125d8

In python the first two line would have produced the desired output.
#+begin_src python :results output :exports both
  a = 3
  b = a
  print("A:", hex(id(a)), "\nB: ", hex(id(b)))
#+end_src

#+RESULTS:
: A: 0x955e80
: B:  0x955e80

Well in C++ things are different and you have to use Reference

Note: This is where the similarity in Python ends, while python just aliases the variable to avoid creating objects in memory. C++ does much more than that


Emulating pointers:

#+begin_src C++ :includes <iostream> :main no :results output :exports both
  void increment_int(int* a){
  // Note: (*a)++ and not *a++ dereference then increment no reference an incremented address
     (*a)++;
  }

  int main(){
    int a = 10;
    int* b = &a;
    increment_int(b);
    std::cout << "A: " << a;
    return 0;
  }
#+end_src

#+RESULTS:
: A: 10

This is standard syntax used when trying to emulate a pass by reference in C. You dont want to pass the actual value 10 but you want to be able to modify it. Passing address of 10 and putting anything in that address is the way

#+begin_src C++ :main no :includes <iostream> :results output :exports both
  void increment_int(int& i){
    i++;
  }

  int main(){
    int a = 10;
    increment_int(a);
    std::cout << "A: " << a;
    return 0;
  }
#+end_src

#+RESULTS:
: A: 11


Losing all that cruft looks nice and it makes perfect sense for a compiler either ways.
The real cost however is Magic. You are no longer passing the the value 10 to function tho it may look like it. The compiler looks at both the function call and function definition and actually makes the translation.

#+begin_src C++
  // func def
  void call_func(int num){}

  // call to function
  int a = 10;
  call_func(a) // --> call_func(10) --> num = 10

  void call_func2(int& num){}
  int a = 10;
  call_func(a) // --> call_func2(&a)
#+end_src

SUMMARY

Pointers do too much.

- References acts as immutable pointer that are automatically dereferenced
- Subset of pointer features to use reference in substitute

  - passing large objects to function arguments
  - Passing things to function for the function to modify the underlying value


DIFFERENCE WITH POINTERS (from bjarne c++ programming priciple and practice book)

- Assignment to a pointer changes the pointer's value (not the pointed-to value).

- To get a pointer you generally need to use new or &.

- To access an object pointed to by a pointer you use * or [].

 - Assignment to a reference changes the value of the object referred to (not
the reference itself).

- You cannot make a reference refer to a different object after initialization.

- Assignment of references does deep copy (assigns to the referred-to object); assignment of pointers does not (assigns to the pointer object itself).

- Beware of null pointers.

*** Class vs Structs
Structs and class in C++ have very little difference. Struct is only for backward compatible reason.

In class the fields and methods declared inside are private unless explicitly made public using the said keyword.
So yeah, the difference is just the private: keyword.

You can go to a C struct replace the struct word with class and add public keyword and boom its a valid c++ and you can replace any valid C++ class with struct and adjust the private keyword and there you go a valid c++ code.
#+begin_src C++
  class Test{
    int priv_a, priv_b;
    void priv_func();
    }

  struct Test{
    private:
      int priv_a, priv_b;
      void priv_func();
}
#+end_src
Both are equivalent. You can literally do a whole class hierarchy and inheritance just using struct heck you can make a struct inherit from class.

So all in all it seems like Bjarne designed classes in C++ then just renamed it to struct and made member public by default thats it

**** Semantic Difference
This is the difference we really care about. Since a whole culture of programmers evolved using struct in C. There are some preconceived roles of structs and class.

- Using class just for storing 2-3 variables kinda seems odd to some.
- So for simple non-complicated stuff having few member and trivial little functions use struct
- For more complicated use, having tons of members, using a constructor, non trivial methods, inheritance and hierarchy use class, structs will just feel out of place

 Again no difference to the compiler just semantic notion and popular convention that's it.

*** Class: Defining methods outside the classes
**** Includes
#+name: DMOCIncludes
#+begin_src C++
  #include <iostream>
#+end_src

**** Addition class definition
#+name: DMOCAdditionClass
#+begin_src C++
  class Addition{
  private:
    int a, b, sum;
  public:
    void get(int x, int y);
    void process();
    void print();
  };

  void Addition::get(int x, int y){
    a = x;
    b = y;
  }

  void Addition::process(){
    sum = a+b;
  }

  void Addition::print(){
    std::cout << "Sum of the " << a << " and " << b << " is " << sum << std::endl;
  }
#+end_src

**** Main loop
#+name: DMOCMain
#+begin_src C++
  int main(){
    Addition A;
    A.get(10, 20);
    A.process();
    A.print();
    return 0;
    }
#+end_src

**** Output
#+begin_src C++ :results output :main no :exports results :tangle ~/dev/csit/class_method_define_outside.cpp :noweb yes
  <<DMOCIncludes>>

  <<DMOCAdditionClass>>

  <<DMOCMain>>

#+end_src

#+RESULTS:
: Sum of the 10 and 20 is 30

*** Class Example: Console Log class
**** Designing API

#+name: LogMain
#+begin_src C++
  int main(){
      Log log;
      log.Info("Setting level to Error");
      log.SetLevel(log.LogLevelError);
      log.Warn("This is warning");
      log.Error("This is error");


      log.SetLevel(log.LogLevelInfo);
      log.Info("Setting level to Info");
      log.Error("This is error");
      log.Warn("This is warning");
      log.Info("This is info");

      return 0;
    }
#+end_src

#+RESULTS: Main

**** Make class
#+name: LogClass
#+begin_src C++
  class Log{
    public:
      const int LogLevelError = 0;
      const int LogLevelWarning = 1;
      const int LogLevelInfo = 2;

    private:
      int m_logLevel = 2;

    public:
      void SetLevel(int level){
        m_logLevel = level;
     }
      void Error(const char* message){
        if(m_logLevel >= LogLevelError)
         std::cout << "[Error]: " << message << std::endl;
      }
      void Warn(const char* message){
        if(m_logLevel >= LogLevelWarning)
         std::cout << "[Warn]: " << message << std::endl;
      }
      void Info(const char* message){
        if(m_logLevel >= LogLevelInfo)
         std::cout << "[Info]: " << message << std::endl;
      }
    };
#+end_src

**** Includes
#+name: LogInclude
#+begin_src C++
  #include <iostream>
#+end_src

**** Output
#+begin_src C++ :main no :noweb yes :exports results :tangle ~/dev/csit/class_log_example.cpp :results output
  <<LogInclude>>

  <<LogClass>>

  <<LogMain>>

#+end_src

#+RESULTS:
: [Info]: Setting level to Error
: [Error]: This is error
: [Info]: Setting level to Info
: [Error]: This is error
: [Warn]: This is warning
: [Info]: This is info

*** Static Keyword for file level
- A keyword that limits the scope of a variable or function within a translation unit
- Very useful for defensive progamming.
- Recommended to use s underscore (s_) convention
- Opposite of extern where a var is only initiliazed in a file and its declaration is on another file

*** Static for class and structs
- declaring a variable static inside a class means the variable will be shared across all the instances of the class.
- Its not created everytime an object is instantiated. If one instance changes this var it is reflected across all instances
#+begin_src C++ :results output :exports both :includes <iostream> :tangle ~/dev/csit/class_static_variables_intro.cpp
  class Test{
    public:
    static int y;
    static int x;

    public:
    void print_x_y(){
      std::cout << x << ", " << y <<std::endl;
      }
    };

  int Test::x;
  int Test::y;

  int main(){
    Test t = Test();
    t.x = 3;
    t.y = 4;
    t.print_x_y();

    Test t1 = Test();
    t1.x = 9;
    t1.y = 8;
    t.print_x_y();

    Test::x = 100;
    Test::y = 200;

    t.print_x_y();
    t1.print_x_y();
  }
#+end_src

#+RESULTS:
: 3, 4
: 9, 8
: 100, 200
: 100, 200

- We need to actually define x and y again outside for linker to link it.
- At this point its kinda ovious that we're modifying a single instace of x and y
- They are similar to being inside the namespace of Test, it does have additional class benefits of being private public etc.
- Very useful for sharing data across class instances instead of creating global variables


- Static method is similar where you get to access the function independent of instance. Conversely this means you cannot write instance dependent code inside the class
  This is similar to @staticmethod decorator in python.
  #+begin_src C++ :results output :exports both :includes <iostream> :tangle ~/dev/csit/class_static_function_intro.cpp
      class Test{
        public:
        static int y;
        static int x;

        public:
        static void print_x_y(){
          std::cout << x << ", " << y <<std::endl;
          }
        };

      int Test::x;
      int Test::y;

      int main(){
        Test::x = 10;
        Test::y = 10;

        Test t = Test();
        t.print_x_y();
        Test::print_x_y();

        t.x = 100;
        t.y = 200;

        t.print_x_y();
        Test::print_x_y();
    }
  #+end_src

  #+RESULTS:
  : 10, 10
  : 10, 10
  : 100, 200
  : 100, 200

  - Both call to print are same but since print doesnot receive the instance it's called from it is recommended to call it directly from Class name instead to make our intent explicit

  #+RESULTS:
  : 10, 10
  : 10, 10

*** Enums
- Giving name for group of integer to make it more readable/organized.
#+begin_src C++ :results output :exports both :includes <iostream> :tangle ~/dev/csit/enum_intro.cpp

  enum TrafficLight{
    RED, YELLOW, GREEN,
  };

  enum Grade : unsigned int{
    A_PLUS=90, A=80, B_PLUS=70, B=60,
  };

  int main(){
    int currentLight = RED;
    if (currentLight < 2){
      std::cout << "STOP" << std::endl;
    }
    Grade level = A_PLUS;
    if (level > A){
      std::cout << "You are an A Plus level student" << std::endl;
    }
    return 0;
  }
#+end_src

#+RESULTS:
: STOP
: You are an A Plus level student

- We can specify the type of enum as interger variations (signed/unsigned char/int) but not float or double since it must be integer
- Vars inside enums are basically a global variable not connected to the namespace so declare them inside a scoped entity like class.
- The holder (currentLight or level) can both be defined as int or name of Enum.
- Declaring using the name of enum (syntactically) limits its assignation to the value other than members of enum.

*** Update: Log Class to use enum
**** The class
#+name: LogClassEnum
#+begin_src C++
  class Log{
    public:
      enum Level: unsigned int{
        LevelError = 0, LevelWarning = 1, LevelInfo = 2
      };

    private:
      Level m_logLevel = LevelInfo;

    public:
      void SetLevel(Level level){
        m_logLevel = level;
     }
      void Error(const char* message){
        if(m_logLevel >= LevelError)
         std::cout << "[Error]: " << message << std::endl;
      }
      void Warn(const char* message){
        if(m_logLevel >= LevelWarning)
         std::cout << "[Warn]: " << message << std::endl;
      }
      void Info(const char* message){
        if(m_logLevel >= LevelInfo)
         std::cout << "[Info]: " << message << std::endl;
      }
    };
#+end_src

#+RESULTS: LogClassEnum

**** Main func
#+name: LogMainEnum
#+begin_src C++
  int main(){
      Log log;
      log.Info("Setting level to Error");
      log.SetLevel(Log::LevelError);
      log.Warn("This is warning");
      log.Error("This is error");


      log.SetLevel(Log::LevelInfo);
      log.Info("Setting level to Info");
      log.Error("This is error");
      log.Warn("This is warning");
      log.Info("This is info");

      return 0;
    }
#+end_src

**** Includes
#+name: LogIncludeEnum
#+begin_src C++
  #include <iostream>
#+end_src

**** Output
#+begin_src C++ :main no :noweb yes :exports results :tangle ~/dev/csit/class_log_example.cpp :results output
  <<LogIncludeEnum>>

  <<LogClassEnum>>

  <<LogMainEnum>>

#+end_src

#+RESULTS:
: [Info]: Setting level to Error
: [Error]: This is error
: [Info]: Setting level to Info
: [Error]: This is error
: [Warn]: This is warning
: [Info]: This is info

*** Constructors
- A constructor is an special method that gets called everytime a class gets instanciated
- Name of the method is same as name of class
  #+begin_src C++ :results output :exports both :includes <iostream>
    class Test{
       public:
         float x, y;

         Test(){
           // Initialize the values to default choice
           x = 100;
           y = 100;
         }
    };

    int main(){
       Test t = Test();
       std::cout << t.x << ", " << t.y << std::endl;
       return 0;
     }
  #+end_src

  #+RESULTS:
  : 100, 100

- Saves hassle of calling setup function for every object instanciation
- Similar to the dunder init method in python
- Similar to function and methods the constructors can also be overloaded to initialized with different sets of parameters

**** Important note
- Initialization of even primitive types is very important in C++ since they aren't done automatically.
- Some compiler will throw error if we try to use it uninitialized so extremely important to have these constructors to take off the surface area of error from programmers shoulders

**** Disabling a constructor
- If you want your class to contain static members only and dont want to let anyone instantiate an object from it, you have an option to do it.
- C++ by default provides an constructor (empty method) for us which gets overrided once we declared our own.
- This is the reason every single class can be instanciated in C++
- A ClassName() function is implicitly called whenever we instanciate an object
  #+begin_src C++
    class Test{};

    int main(){
      Test t = Test(); // powered by the default empty constructor
    }
  #+end_src

- To disable it either you define your own constructor and make it private.
  #+begin_src C++
    class Test{
      private:
        Test(){}
    };

    int main(){
      Test t = Test();
    }
  #+end_src

- Disabling it causes the implicit call of Test::Test() to fail as it is private.
  #+begin_example
    main.cpp: In function int main():
    main.cpp:7:21: error: Test::Test() is private within this context
        7 |       Test t = Test();
          |                     ^
    main.cpp:3:9: note: declared private here
        3 |         Test(){}
          |         ^~~~
  #+end_example

- Or you can also delete the default constructor without overriding it with your own
  #+begin_src C++
    class Test{
      public:
        Test() = delete;
    };

    int main(){
      Test t = Test();
    }
  #+end_src

- During implicit constructor method call, compiler complains about deleted stuff

#+begin_example
  main.cpp: In function int main():
  main.cpp:7:21: error: use of deleted function Test::Test()
      7 |       Test t = Test();
        |                     ^
  main.cpp:3:9: note: declared here
      3 |         Test() = delete;
        |         ^~~~
  main.cpp:7:12: error: unused variable [-Werror=unused-variable]
      7 |       Test t = Test();
        |            ^
#+end_example

*** Destructors
- Called when object is deleted. Useful to do cleanup tasks (memory free, files delete, free locks)
- Objects get deleted
  - When we use new keyword to create an object and later destroy it with delete keyword
  - When a stack scoped object gets out of scope and gets destroyed
#+begin_src C++ :results output :exports both :includes <iostream> :tangle ~/dev/csit/class_destructor.cpp
  class Test{
    public:
      Test(){std::cout << "Constructor called." << std::endl;}
      ~Test(){std::cout << "Destructor called." << std::endl;}
  };

  int scopedFunc(){
    std::cout << "<Func>" << std::endl;
    Test t = Test();
    std::cout << "</Func>" << std::endl;
    return 0;
  }

  int main(){
    std::cout << "<Main>" << std::endl;
    scopedFunc();
    std::cout << "</Main>" << std::endl;
  }
#+end_src

#+RESULTS:
: <Main>
: <Func>
: Constructor called.
: </Func>
: Destructor called.
: </Main>

- We can also call destructor manually unlike with constructor just using
- There is not good usecase for this though, super rarely used.
  #+begin_src C++ :includes <iostream> :exports both :results output
    class Test{
      public:
        Test(){std::cout << "Constructor called." << std::endl;}
        ~Test(){std::cout << "Destructor called." << std::endl;}
    };

    int main(){
      Test t = Test();
      t.~Test(); // calls destructor
    }
  #+end_src

  #+RESULTS:
  : Constructor called.
  : Destructor called.
  : Destructor called.

*** Inheritance
- Just a way to reuse an existing class to build a superset
- Code Reuse and better real life model
  #+begin_src C++ :results output :exports both :includes <iostream> :tangle ~/dev/csit/class_inheritance_intro.cpp
     class Person{
       private:
         int name, height;
       public:
         void walk(){
           std::cout << "Walking " << std::endl;
           }

         void write(){
           std::cout << "Writing " << std::endl;
        }
     };

    class Student : public Person{
      public:
        void attend_class(){
          std::cout << "Attending class" << std::endl;
        }
      };

    int main (){
       Student tim = Student();
       tim.walk(); // walk to college
       tim.attend_class(); // Attend the class
       tim.write(); // Take notes maybe
   }
  #+end_src

  #+RESULTS:
  : Walking
  : Attending class
  : Writing

- The Student inherits everything from Person and optionally can extend itself with additioinal functionality
- The Student is guarenteed to be a superset of Person class.
- The ojbect tim is of both types (Student and Person)
- This introduces polymorphism where now tim can use any method designed for both Person and Student since it is both.
*** Virtual Function
- Method overriding kinda breaks polymorphism
  #+begin_example
  class1->func {returns '1'}
  class2->func {returns '2'}

  class1* c1 =  new class2();
  c1->func  // returns '1'
  #+end_example
  More specifically (same thing explicitly)
  #+begin_example
  void print_class(class1* c){
        cout << c->func() ;
  }
  class2* c2 = new class2()
  print_class(c2) // prints 1
  #+end_example

This happens since the function signature of =print_class= matches more accurately with class1 so it just directly calls its method without bothering to look if =class2= is overriding/contains same method as well.

- Example in C++ code:
#+begin_src C++ :results output :exports both :includes <iostream>
  class Parent{
    public:
    int func() {return 1;}
    };

   class Child : public Parent{
     public:
    int func() {return 2;}
    };

  void print_func(Parent* obj){
    std::cout << obj->func() << std::endl;
    }

  int main(){
    Parent* obj = new Child();
    std::cout << obj->func() << std::endl;

    Child* obj2 = new Child();
    print_func(obj2);
    }
#+end_src

#+RESULTS:
: 1
: 1


  SUMMARY: Well overriding parent's method work only in some simple cases but breaks in others like above

  Explicitly provide =virtual= keyword while defining methods in parent class if that method is to be overridden.

  *since c++ 11* :
  - We also have option to specify this explicitly at child class level also by providing =override= keyword.
  - It is not required but recommeded practice to document both child and parent class so we get strict checking and prevent typos errors.


#+begin_src C++ :results output :exports both :includes <iostream>
  class Parent{
    public:
    virtual int func() {return 1;}
    };

   class Child : public Parent{
     public:
    int func() override {return 2;}
    };

  void print_func(Parent* obj){
    std::cout << obj->func() << std::endl;
    }

  int main(){
    Parent* obj = new Child();
    std::cout << obj->func() << std::endl;

    Child* obj2 = new Child();
    print_func(obj2);
    }
#+end_src

#+RESULTS:
: 2
: 2

*NOTES*:
- This feature is enabled by compiler taking extra notes of stuff using vtables. So we incur memory and performance overhead.
- Generally unnoticable overhead unless you know in microcontroller or contrained environments

*** Interfaces (Pure virtual functions)
- =virtual= keyword hints compiler there may be child's version of a function. Whereas interface or pure virtual function require the child to do so and don't have any implementation at parent's side.
- So use virtual option when you have a general default fallback implementation.
- Use interface when it doesnot makes any sense to provide any implementation at parent's side (eg due to lack of req info)

- In python, we often design classes and methods in such a way to force subclasses to define their own method.
  #+begin_src python :eval never
    class Person:
        def get_gender():
            raise NotImplementedError("")

        @abstractmethod
        def get_gender():
            pass
  #+end_src

  #+RESULTS:

- This exposes the function name as an api but if the subclass doesnot provide an implementation an error is going to be issued
- The =@abstractmethod= won't let you instantiate without implementing all parent funcs
- The raise trick only works when calling the =get_gender= function so less strict/enforced.


#+begin_src C++ :eval no-export
  class Parent{
    public:
    virtual int func() = 0;
    };

   class Child : public Parent{
    };

  int main(){
    Parent* p = new Parent();
    Child* c = new Child();
    }
#+end_src

- you cannot ever instantiate a parent class with a pure virtual function.
- You also wont be able to instantiate  a child class unless it has implemented that virtual function
- Note: however the implementation has to be only once in a tree. A child whose parent has already implemented a pure virtual function doesnot need to implement its own
#+begin_example
main.cpp: In function ‘int main()’:
main.cpp:17:26: error: invalid new-expression of abstract class type ‘Parent’
   17 |   Parent* p = new Parent();
      |                          ^
main.cpp:8:7: note:   because the following virtual functions are pure within ‘Parent’:
main
main.cpp:10:15: note: 	‘virtual int Parent::func()’
main 0;
main.cpp:18:24: error: invalid new-expression of abstract class type ‘Child’
main();
main.cpp:13:8: note:   because the following virtual functions are pure within ‘Child’:
mainParent{
main.cpp:10:15: note: 	‘virtual int Parent::func()’
main 0;
#+end_example


#+begin_src C++ :results output :exports both :includes <iostream>
  class Parent{
    public:
    virtual int func() = 0;
    };

   class Child : public Parent{
     public:
    int func() override {return 2;}
    };

  int main(){
    Child* p = new Child();
    std::cout << p->func() << std::endl;
    }
#+end_src

#+RESULTS:
: 2

- Example usage
  #+begin_src C++ :results output :exports both :includes <iostream>
    class Printable{
      public:
      virtual void print() = 0;
      };

    void print_sth(Printable* p){
     p->print();
      }

    class String: public Printable {
      public:
      void print() override {std::cout << "Print like string" << std::endl;}
      };

    class Integer: public Printable {
      public:
      void print() override {std::cout << "Print like int" << std::endl;}
      };

      int main(){
        print_sth(new String());
        print_sth(new Integer());
        }
  #+end_src

  #+RESULTS:
  : Print like string
  : Print like int

  - Here, we must have something to guarentee in the =print_sth= function that our parameter has an implementation of the =print= function that we are calling.

*** Arrays
- Important fact how a data is stored in memory
  #+begin_src C++ :results output :exports both :main yes :includes <iostream>
    int i = 5;
    std::cout << &i << std::endl;
  #+end_src

  #+RESULTS:
  : 0x7fffa54c08a4

  * What it means for a computer to be 16/32/64 bit processor.
   - The <x>-bit generally refers to the address and data bus width.
  - The addr bus determines the range of unique memory address there can be in a memory
  - Data bus specifies how much data can flow at a time through the bus lines (parallelly)

  * Note however, though the adress length might coresspond to 32-bit/64-bit system, its not true for data.
  * https://stackoverflow.com/questions/5215495/one-memory-location-in-a-computer-stores-how-much-data
  * One memory location stores 1 byte. This can be thought as helpful abstraction (not technological limitation). The official term is =byte addressable=

  | addresses        | a4 | a5 | a6 | a7 | a8 | a9 | aa |
  | 0x7ffc93558e[a4] | 05 | 00 | 00 | 00 | cc | zz | hh |
  | 0x7ffc93558e[ab] | bd | ac | 9a | cc | 1b | ee | ff |
  | 0x7ffc93558e[b2] | aa | ff | bb | ee | dd | bb | aa |
  | 0x7ffc93558e[b9] | aa | 04 | 00 | 33 | 88 | 33 | 2b |

  The type information is only useful in that compiler now can take only first 4 8-bit things out of that address. Otherwise no way to know how much to take

  Also notice that ordering of these byte are in reverse order because of POP opcode effect. ~05 00 00 00~ is =5= and ~00 01 00 00~ is =4096=  (=1000= in hex).

**** About storing char arrays or arrays in general in memory
- For example a char array of 4 chars (4 byte) will be stored contiguously in 4 serial memory address =0x00029B[30/31/32/33]= and also 34 for null terminating char.
- Eg. We're storing "=Raju=" =[52 - R, 61 - a, 6a - j, 75 - u, 00 - '\0']=. The numbers are in hex not int so convert to compare in ascii table

| 0x00029B30 | 52 | 61 | 6a | 75 | 00 | 00 |
| 0x00029B69 | 00 | 00 | 00 | 01 | 00 | 00 |
| 0x00029BA2 | 65 | 20 | 76 | 61 | 72 | 69 |
| 0x00029BDB | 00 | 48 | 65 | 6c | 6c | 6f |
| 0x00029C14 | 20 | 6e | 6f | 74 | 20 | 70 |
| 0x00029C4D | 6c | 6c | 79 | 20 | 61 | 20 |

- In this case, each char gets its own adress. Thus its equivalent for us to do =array[1]= notation vs ~*(array+1)~ notation
- Now, this gets changed in case of integers.

| 0x005BFA64 | 01 | 00 | 00 | 00 | 02 | 00 | 00 | 00 | 03 | 00 | 00 | 00 | 04 | 00 | 00 | 00 | cc | d8 |
| 0x005BFA9D | 59 | 43 | f7 | c0 | fa | 5b | 00 | 63 | 2d | 02 | 00 | 01 | 00 | 00 | 00 | c8 | ae | a1 |
| 0x005BFAD6 | 72 | 00 | 00 | 00 | 00 | 00 | 00 | 00 | 00 | 00 | 00 | 00 | 00 | 00 | 00 | 00 | 00 | 00 |
| 0x005BFB0F | 00 | 00 | 4a | 02 | 00 | 68 | 11 | 1a | f7 | 00 | 00 | 00 | 00 | 24 | fb | 5b | 00 | 4d |

- Here each byte (8-bit) gets its own address so the int occupies 4 mem addr actually.
- Here doing ~*(array+1)~ will give your =00= but ~array[1]~ gives your =02= since compiler translates for you.
-  So yeah ~[]~ is a syntactic sugar for memory addr arithmetic but actually does more than help avoiding ugly ~*(array+1)~ i.e translates units to determine next mem addr with relevant data.
*** Strings in C++
- Group of chars (letters, nums, text)
- Ends in ~\0~ null terminating char
- Since built-in char in cpp is 1 byte (8-bit), we only have ascii representation of 256 possibilities.
- Thus using unicode chars wont work in cpp strings
- const =char*= is very basic its just a contiguous block of memory addr ending with NULL termination
- Stdlib =string= is a template specialization of ~char~. with ~char*~ functionality with class and many more helper functions.
#+begin_src C++ :results output :exports both :includes <iostream>
   int main(){
     std::string name = "Name";
     std::string fullname = "Mr. " + name + " " + "Surname";
     std::cout << name << std::endl;
     std::cout << fullname << std::endl;
  }
#+end_src

#+RESULTS:
: Name
: Mr. Name Surname

Appending with ~+~ operator works because the one of operand is a proper string class so it is notified of the operation thereby kicking overload function into action which takes care of appending the string.

 * *NOTE* In some cases
 String is available through ~iostream~ header but we may still need to load ~string~ header file because cout will throw an error. cout relies in string doing the overloading of ~<<~ operator to get a compatible printable type. This overload is only available using the ~string~ header.

- Passing a string to function copies the string as a whole which is inefficient incase we just want to read it and promise to not modify it.
- We use const string references in those cases.
#+begin_src C++ :results output :exports both :includes <iostream>
    void printer(const std::string& str){
      std::cout << str << std::endl;
    }
    int main(){
        printer(std::string("Name"));
    }
#+end_src

#+RESULTS:
: Name

*** String literals
- When something is typed enclosed by a double quotes (eg "~this~"), it is called a string literal
- How is it interpreted? As typing literal =3= will be interpretered as an int datatype, by default string literals are inferred as =const char array= of size n (5 in case of "~this~" due to additional '~\0~').
- We can string literals assign explicitly ~const char*~ instead of array as well.
- By using const we're promising not to change it as strings are supposed to be immutable.
- However, if we remove the const and modify some index like we'd do to an array, we can encounter in one of two states.
- Compiler like clang wont compile it and give error whereas msvc will allow it. The cpp specification doesnot specify any behaviour it's undefined/banned case and we shouldnot rely on compilers implementing it.

#+begin_src C++ :results output :exports code :includes <iostream>
  int main(){
    char* name = "Raju";
    name[3] = 'a';
    std::cout << name << std::endl;
    }
#+end_src

- The *core* reason to all of this is that string literals are stored in special /read-only section/ of the memory. The assembly output will show you that any string is stored in const section of the binary file.
- The release mode of msvc will ignore the array index modification and display the string as is and debug mode will raise ~runtime write access violation~
- If you wanted to /modify/ a string for some reason just use ~char arrays~ (not ~char*~).
- Note that string /are always/ stored in const read-only segment of memory but there is some vodoo special support magic happening in this case only. (A new name variable gets created in register etc learn more)

#+begin_src C++ :results output :exports both :includes <iostream>
  int main(){
    char name[] = "Raju";
    name[3] = 'a';
    std::cout << name << std::endl;
    }
#+end_src

#+RESULTS:
: Raja


- Using utf 8, 16, 32 strings (from cpp version 11)
#+begin_src C++ :results output :exports both :includes <iostream>
  int main(){
    const char* name = "hello";
    // wchar_t is a wide char where each char is allocated more than one (2 or 4) bytes
    const wchar_t* name2 = L"hello"; // we need capital L otherwise error
    // char16_t says 16 bits or 2 bytes(8-bit). so each char is fixed 2 bytes guarenteed.
    const char16_t* name3 = u"hello";
    // In char32_t, each char is 4 bytes. Designed to adhere to utf-32
    const char32_t* name4 = U"hello";
    // normal char* can also be specified with u8 at front
    const char* name5 = u8"hello";
    std::cout << name << std::endl;
    std::cout << name4 << std::endl;
    std::cout << name3 << std::endl;
    // name2 -> wchar_t is 2 byte in windows and 4 bytes in linux (so similar to name4)
    std::cout << name2 << std::endl;
    }
#+end_src

#+RESULTS:
: hello
: 0x55649db1100c
: 0x55649db11024
: 0x55649db1100c

- String appending keywords (since cpp 14)
#+begin_src C++ :results output :exports code :includes <iostream>
  int main(){
    using namespace std::string_literals;

    std::string name = "hello"s + " world!";
    std::wstring name1 = L"hello"s + L" world!";
    std::u32string name2 = U"hello"s + U" world!";
  }
#+end_src

- String multiline format
#+begin_src C++ :results output :exports both :includes <iostream>
  int main(){
    using namespace std::string_literals;
    std::string name = R"(hello
  world
  line3)";
    std::string name2 = "Line1"
                       "Line2"
                       "Line3";
    std::cout << name << std::endl;
    std::cout << name2 << std::endl;
  }
#+end_src

#+RESULTS:
: hello
: world
: line3
: Line1Line2Line3

*** Const keyword
- In cpp, const is actually a loose term. It is just a promise to not modify something however, like with the nature of promises, it can be broken.
- Use cases of const.
- ~const varname or const type* varname~
   in such cases, it will be illegal to change the *value* pointed by the pointer/variable. but it is actually possible to entirely change /where/ the pointer actually points to.
#+begin_src C++ :results output :exports both :includes <iostream>
  int main(){
    const int MAX_AGE = 19;
    const int* a = new int;

    // *a = 3 // Not allowed
    a = (int*)&MAX_AGE; // Allowed since the pointer itself isn't constant
    std::cout << *a << std::endl;
    }
#+end_src

#+RESULTS:
: 19

- ~type* const varname~
   Here you can freely change the value pointed by the pointer, but cannot change where the pointer points to.
#+begin_src C++ :results output :exports both :includes <iostream>
  int main(){
    const int MAX_AGE = 19;
    int* const a = new int;

    *a = 3; // Allowed, changing the value
    // a = (int*)&MAX_AGE; // Not Allowed
    std::cout << *a << std::endl;
    }
#+end_src

#+RESULTS:
: 3

- Confusing order  ~const type const * const varname~
Actually ~const int* name~ and ~int const* name~ are exactly the same. Remeber the difference is with if const is written before or after the asterisk.
#+begin_src C++ :results output :exports both :includes <iostream>
  int main(){
    const int MAX_AGE = 19;

    // same as const int* a
    int const* a = new int;
    a = (int*)&MAX_AGE; // Allowed for 'a'
    // *a = 3; Not Allowed

    int* const b = new int;
    *b = 3; // Allowed, changing the value
    // b = (int*)&MAX_AGE; Not Allowed

    int const* const c = new int; // same as const int* const c
    // *c = 3; // Not Allowed
    // c = (int*)&MAX_AGE; // Not Allowed

    std::cout << *a << "\n" << *b << std::endl;
    }
#+end_src

#+RESULTS:
: 19
: 3

- Const after function parenthesis before curly braces *inside class only*
   This specifies that the member function is not going to modify the data of the class, its only reading but not modifying.
   Example usecase is Getter member functions.
- One important thing to note here is when you have a function that takes an object by const reference, you can only call the methods of that object that are marked const. This is because you are taking a const ref of object thereby implying you donot have right to change its internal state
#+begin_src C++ :results output :exports both :includes <iostream>
  class Test{
      int x = 3;
      int* y = new int;
      public:
      void hello() const {
        std::cout << "Hello" <<x <<std::endl;
        }
      void const bye() const {
        std::cout << "Hello" <<*y <<std::endl;
        }
      const int* const get_y() const { // A const get_y func returning const * to a const int
        ,*y = 4;
        std::cout << "Hello" <<*y <<std::endl;
        return y;
        }
  };

  int main(){Test t; t.hello(); t.bye(); t.get_y();}
#+end_src

#+RESULTS:
: Hello3
: Hello0
: Hello4

- When you mark a class method as const, you can't change/modify class internal variables. If you really really need to though, cpp has yet another keyword called mutable, when you declare any variable as ~mutable type varname~ you can modify them even inside const member functions.
#+begin_src C++ :results output :exports both :includes <iostream>
  class Test{
      mutable int x = 3;
      public:
        void hello() const {
          x = 100;
          std::cout << "Hello" <<x <<std::endl;
        }
  };

  int main(){Test t; t.hello();}
#+end_src

#+RESULTS:
: Hello100

**** Useful note from the comments
For people having trouble remembering the order in which const keyword is to be used, here's a quick tip.
You have to read it backward, like the compiler does. For instance :

~const int * A;~ ==> "A is a pointer to an int that is constant."
(or, depending on how you prefer to write it)
~int const* A;~ ==> "A is a pointer to a const int"
but both are the same as explained in the video.

~int * const A;~ ==> "A is a const pointer to an int."
~const int* const A;~ ==> "A is a const pointer to an int that is constant".

Note that, ~const int * A~ /does not/ mean that A actually points to a =const variable=. It just means that the compiler /will not allow/ you to modify the *pointed value through A*.

for instance :
#+begin_src C++ :results output :exports code
int val = 10;
int const * a = &val;
// *a = 30; //this will NOT compile, you're not allowed to modify "val" through "a".
val = 30; //this will compile.
#+end_src

Same with :
#+begin_src C++ :results output :exports code
int val = 10;
int val2 = 30;
const int * const A = &val;

// A = &val2; //will NOT compile : you can't modify what A points to.
// *A = 30; //will NOT compile : you can't modify val through A
val = 30; //this will compile, val is not constant
#+end_src

*** Mutable
- As stated earlier, in ~const~ notes, any class property marked mutable can be modified in ~const methods~ as well.
#+begin_src C++ :results output :exports both :includes <iostream>
  class Test{
      int a = 45;
      mutable int debugCounter = 0;
      public:
        const int& getA() const {
          debugCounter += 1;
          return a;
       }
  };

  int main() {Test t; const int& a = t.getA(); std::cout << a; }
#+end_src

#+RESULTS:
: 45

- Another usecases is with Lambdas
- Normally, when you pass variables inside lambdas by value, you cannot change them.
  You can mark the lambda func itself as mutable, to change the values of variables =passed by value=
- However, it just creates a new variable inside the lambda scope, copies the value and then modifies it, to give us the illusion of modification.
  Accessing the value of that variable outside the lambda will appear unchanged. (Which makes sense since you're not passing by reference but by value)
#+begin_src C++ :results output :exports both :includes <iostream>
  using namespace std;
  int main(){
    auto h = [](){std::cout << "Hello" << std::endl;};
    h();

    // = or & in [] passes every vars (in current scope) by value or by reference respectively.
    // you can also put each variables manually/directly like [x].
    int x = 8;
    auto f = [=]() mutable
      {
        x++;
        std::cout << x << std::endl;
      };
    f();
    std::cout << x;
    }
#+end_src

#+RESULTS:
: Hello
: 9
: 8

*** Member Initializer List
- Way for us to initialize members inside the constructor
- This is written after a ~:~ at the constructor definition.
- Note, that the members will be initialized in order of their definition, regardless of their order in the initializer list in constructor.
#+begin_src C++ :results output :exports both :includes <iostream>
  class Test{
    int m_i;
    int m_j;
    public:
      Test()
        : m_i(0), m_j(0)
      {}
      Test(const int i, j)
      // Order (here) doesn't matter 'i' gets initialized first then only 'j'
        : m_j(j), m_i(i)
      {}
  };
#+end_src

- Why?
- Separation of the actual action the constructor does from just routine member initializing chore.

- Functional difference
- CASE 1
When we state class members in private/public definition, we're are calling the object's default constructor.
When we actually initlialize them later in our constructor, we again call the objects constructor with our arguments.
This creates two objects, one of which is discarded automatically.
#+begin_src C++ :results output :exports both :includes <iostream>
  class Helper{
    public:
      Helper(){std::cout << "Created empty" <<std::endl;}
      Helper(int x){std::cout << "Created with " << x << std::endl;}
  };

  class Test{
    Helper h; // calls Helper empty constructor
    public:
      Test(){
        h = Helper(9); // we are here now initializing h to Helper(9)
      }
  };

  int main(){Test t;}
#+end_src

#+RESULTS:
: Created empty
: Created with 9

- This causes unnecessary wastage and performance overload. Thus to create an object only once we use memeber initializer list.
- However, incase of primitive types like ~int~, it wont initialize until we explicity do so but still in string and custom datatype we are creating two items.
#+begin_src C++ :results output :exports both :includes <iostream>
  class Helper{
    public:
      Helper(){std::cout << "Created empty" <<std::endl;}
      Helper(int x){std::cout << "Created with " << x << std::endl;}
  };

  class Test{
    Helper h;
    public:
      Test()
        :h(9)
      {}
  };

  int main(){Test t;}
#+end_src

#+RESULTS:
: Created with 9

- Another functional difference is with constructor argument having same name as internal class member variables.
- It is often difficult and counter-productive to write a different name just because a member variable of same name already exists.
- Member initializer list makes it possible to have the same name in constructor arguments with no problems.
#+begin_src C++ :results output :exports code :includes <iostream>
  class Test{
    int x,y;
    public:
      Test(int x, int y)
        : x(x), y(y)
      {
        // Doing this is not allowed both x are same and refer to argument var
        // x = x;
      }
  };
#+end_src

- Note, that there is also another solution to the given problem beside using member initializer list, It's called the =this= keyword which is a separate topic.

*** Ternary Operators
- If statement compressed version. Kinda like lambda for conditionals.
#+begin_src C++ :results output :exports both :includes <iostream>
  int main(){
    int a = 5;
    const char* b = a%2==0? "even" : "odd";
    std::cout << b << std::endl;
  }
#+end_src

#+RESULTS:
: odd

- Argument passing to function
#+begin_src C++ :results output :exports both :includes <iostream>
  void temp(const char* x){
    std::cout << "i is " << x << std::endl;
  }

  int main(){
    int i = 5;
    temp(i%2 == 0? "even" : "odd");
  }
#+end_src

#+RESULTS:
: i is odd

- Nesting ternary operators is also possible.
#+begin_src C++ :results output :exports both :includes <iostream>
  int main(){
    int a = 5;
    const char* b = a%2==0? "even" :
                      a==5? "five" :
                            "odd";
    std::cout << b << std::endl;
    }
#+end_src

#+RESULTS:
: five

*** Create/instantiate objects
- Unless defined as ~static~ every class needs to be instantiated to objects.
- One major factor is where the object is instantiated ? heap part of memory or the stack part.
- By default an object is allocated memory in the stack. The lifetime of that object is now managed automatically.
- Whenever, the scope the object was defined in, gets finished, the object is auto destroyed.
#+begin_src C++ :results output :exports both :includes <iostream>
  class Test{
    int i;
    public:
      Test():i(0){}
      Test(int x):i(x){}
      ~Test(){std::cout << i << " Got destoyed" << std::endl;}
  };

  int main(){
    {
      // All are equivalent and will call Test with default constructor
      Test t;
      Test t2(1);
      Test t3 = Test(2);
    }
    return 0;
  }
#+end_src

#+RESULTS:
: 2 Got destoyed
: 1 Got destoyed
: 0 Got destoyed

- TIP: ~Test t()~ is actually an ambiguous since it could be interpreted as function declaration, however ~Test t(1)~ (with argument) removes the ambiguity and thus works.

- This is the recommended way to create an object, do not prefer the other method unless you're limited by this method, i.e need to access the objects even after the scope where they were defined, ended.

- Other option, using ~new~ keyword will also create a new object but the objects live in the heap memory
- Also the ~new~ keyword will give you a pointer to the starting memory location of where the objects was stored
- The syntax is ~Test* test = new Test();~
- Allocation on heap is slower, you need to manually free it afterwards to prevent memory leakage.
- *Memory leakage* is the problem where your program takes memory after memory for storing objects in heap but since it's never cleared the memory you program takes increases till your system gets overwhelm. You program may crash, fail, or entire system will be affected.
- Calling ~delete objname~ or ~delete test~ will perform manual deletion of objects stored in heap.

*** The New Keyword
- Allocates memory for an object in the heap.
- ~new type~ is the syntax.
- =New= determines the necessary size of the type in bytes.
- Then =New= asks the =OS or c standard lib= for the memory
-  Then that ~memory layer~ looks in the =heap= to find contiguous memory of the given size
- Once found, =new= gets the pointer to that address of the first block and returns it.
- Depending upon the size of memory that we need to allocate on heap, the time to search increases.
- The free contiguous block is searched with the help of a list called =free list= that mantains the free bytes.
- Examples:
  - Allocating 4 bytes of memory for integer.
     - ~int* a = new int;~
  - Allocating memory for array of 50 ints. (200 bytes)
     - ~int* a = new int[50];~
  - The same can be done with custom classes.
     - ~Class* c = new Class();~
     - ~Class* c = new Class[50];~

- Note that =new= also takes care of calling the constructor of the object while also allocating memory for it.

- At the fundamental level, =new= is an operator. Thus, you can overload it.
- =new= operator will find the size to be allocated and then calls the underlying =malloc()= function in =C=.
- The =malloc= function takes the size and returns a =void*= which is casted back into required type.
- So, the following code are kinda equivalent,
  - ~Entity* e = new Entity();~
  - ~Entity* e = (Entity*) malloc(sizeof(Entity));~
- The only difference being that =new= will also /call the constructor/ which =malloc= doesn't.

- when using =new= you must always accompany with =delete=.
     - ~int* a = new int;~
     - ~delete a;~
    - Also in case of array, you have to call =delete= with =[]= brackets.
     - ~int* a = new int[50];~
     - ~delete[] a;~

 - =new= can also be given a pointer to specify exactly where in heap; to allocate the memory
    - ~int* a = new int;~
    - ~int* b = new(a) int;~

*** Implicit conversion and Explicit keyword
#+begin_quote
This part is where insanity starts to fade in, you finally get what others mean by cpp being a clusterfuck.
#+end_quote
- Anyway, lets talk about implicit conversion
- Let's say you've got a class with a constructor that takes in a int.
- You can now say ~Class varname = 3~ and a varname object gets initialized passing the int 3 to class's constructor
- See, varname is of type =Class= and =3= is of type =int=, obiously we can't assign them directly so, =cpp= assumes in your place and does the work of calling Class constructor with 3 and assigning the resultant object to =varname=
- This is called implicit conversion.
#+begin_src C++ :results output :exports code :includes <iostream>
  class Test{
    public:
    Test(int i){}
  };

  int main(){
    Test t = 3; // same as Test t(3); or Test t = Test(3);
 }
#+end_src

- Oh yeah, this means any function that takes in an object of type ~Test~ as its argument can be given a int and yes cpp will assume and do extra shit for you and convert that =3= to a ~Test~ object and pass it to a function. Oh! for christ sake.
#+begin_src C++ :results output :exports both :includes <iostream>
  class Test{
     public:
     Test(int i){}
   };

  void printer(const Test& t){
    std::cout << "oh no" << std::endl;
  }

  int main(){
     Test t = 3; // same as Test t(3); or Test t = Test(3);
     printer(2);
  }

#+end_src

#+RESULTS:
: oh no

*Enters The Explicit Keyword*
- =explicit= is a keyword in cpp that disables all this magic to keep things sane.
- While defining a constructor you can use the =explicit= keyword.
- eg. ~explicit Test(){}~ instead of just ~Test(){}~

 - Not much help, =explicit= is not much used. Just Know that implicit conversion exists and pray that'll never haunt you.

*** Operator and Operator Overloading
- There are many operators beside arithmetic ones.
- =<<= used in =cout=, =*= dereference operator, =&= ampersand operator, =->= angular operator,
- Also =new= and =delete= are also operators.
- similarly, comma (,) and =(= (parenthesis) are also operators.

- Defining and changing the behaviour of such operators is called operator overloading.
- Operators under the hood like =+=, =-= are just functions, so it makes sense to be able to write function named =+=.
- However, misuse of these feature can bring major headache to your code.
- Always make sure your overload of any operator is natural, intuitive and makes sense. And nobody has to look at the definition code to figure out what vodoo magic it does.
#+begin_src C++ :results output :exports both :includes <iostream>
  struct Vector2{
    float x,y;
    Vector2(float x, float y): x(x), y(y) {}
    Vector2 operator +(const Vector2& other) const{
      return Vector2(x + other.x, y + other.y);
    }
    Vector2 Add(const Vector2& other) const{
      return operator+(other);
    }
  };

  std::ostream& operator<<(std::ostream& stream, const Vector2& other){
    stream << other.x << ", " << other.y;
    return stream;
  }

  int main(){
    Vector2 v1(1,2);
    Vector2 v2(3,4);
    Vector2 v3 = v1.Add(v2) + v2;
    std::cout << "Sum " << v3.x << " " << v3.y <<std::endl;
    std::cout << "Result Vector " << v3 <<std::endl;
  }
#+end_src

#+RESULTS:
: Sum 7 10
: Result Vector 7, 10

*** this keyword
- A keyword available inside a member function. (method of class)
- Refers to the current instance, the exact object currently running the function.
- similar to =self= in python and =this= in javascript.
- The =this= keyword also helps in initialization of variables during constructor call if the constructor args and member vars have same name.
- However, note that in a =const= member function, =this= will point to =const Entity= object
- It is also very useful in case when we want to call an external function that takes current object as parameter. Just pass =this=.
#+begin_src C++ :results output :exports code :includes <iostream>
  class Test{
    int x,y;
    public:
    Test(int x, int y){
      this->x = x; // remove the ambiguity
      this->y = x; // embrace the 'this' keyword.
    }
  };
#+end_src

- It is also a very good idea to prefix member variables and methods with =m_= prefix. Just to remove ambiguity rather than using this everywhere to do the same. i.e using =this= to remove ambiguity of variables with same name isn't very common.

*** Object Lifetime (Stack/Scope Lifetimes)
- We already know, an object created on the stack gets destroyed as soon as it goes out of scope.
- We can use =new= keyword to allocate objects on the heap, but we have to manually call =delete= to free the memory.
- We can use the fact that stack object gets destroyed once out of scope to make locks and scoped pointers
#+begin_src C++ :results output :exports both :includes <iostream>
  class Test{
      public:
      Test(){std::cout << "Test is Created" << std::endl;}
      ~Test(){std::cout << "Test is Destroyed" << std::endl;}
  };

  class ScopedPtr{
    Test* t;
    public:
    ScopedPtr(Test* t): t(t){}
    ~ScopedPtr(){delete t;}
  };

  int main(){
     // a simple scope
    {
       ScopedPtr a = new Test(); // implicit conversion at play here
    }
  return 0;
  }
#+end_src

#+RESULTS:
: Test is Created
: Test is Destroyed

- There you go our own smart pointer, that automatically calls new and delete using the automatic stack destruction feature.

*** Smart Pointers
- Automating heap allocation and freeing (calling =new= and =delete=) is the core goal of smart pointers.
- There are various ways/angle of approaching this problem depending on the domain space.
- You should always try to use it as much as you can to avoid tracking delete calls.
- They however, do have bit of an overhead, but remember, implementing your own memory management will have too.
- Prefer =unique_ptr= more over others.
**** Unique Pointer
- =unique_ptr= is scoped pointer, it just emulates destruction mechanism of stack objects.
- =unique_ptr= is called unique because it cannot be copied as any one of pointer going out of scope would free the memory that the copied poiners were pointing at.
- Thus, =unique_ptr= is used when you want a single instance and stack styled scoped ptr.
- In =unique_ptr=, the constructor is set to explicit [[*Implicit conversion and Explicit keyword][(learn more),]] so we cannot use assignment (~=~) to instantiate a =unique_ptr=.
- Similarly, the correct way to initialize is to use the wrapper ~std::make_unique<Type>();~.
#+begin_src C++ :results output :exports both :includes <iostream>
  #include <memory>

  class Test{
      public:
      Test(){std::cout << "Test is Created" << std::endl;}
      ~Test(){std::cout << "Test is Destroyed" << std::endl;}
  };

  int main(){
    {
       // std::unique_ptr<Test> test = new Test(); // INVALID
       std::unique_ptr<Test> test(new Test());
       std::unique_ptr<Test> test1 = std::make_unique<Test>();
    }
  return 0;
  }
#+end_src

#+RESULTS:
: Test is Created
: Test is Created
: Test is Destroyed
: Test is Destroyed

- Similarly, copying a unique pointer is not possible as the =copy constructor= and =copy assignment operator= are both marked *deleted* in stdlib declaration.
#+begin_src C++ :results output :exports code
// member function inside unique pointer class
class unique_ptr{
  unique_ptr(const _Myt&) = delete;
  _Myt& operator=(const _Myt&) = delete;
};
#+end_src

**** Shared Pointer
- =shared_ptr= is a scoped pointer that can be copied and it keeps track of all copies via reference count.
- Everytime a copy of ptr dies, the reference count is decremented until it reaches zero which means the object is destroyed from the heap.
- A copy of ptr dies when it goes out of scope. So =shared_ptr= is a scoped ptr having the longetivity of outermost scoped ptr copy.
- There is also ~std::make_shared<Type>();~ to instantiate a =shared_ptr=, along with the constructor notation similar to =unique_ptr=.
- However, calling ~new Type();~ (constructor notation) is not recommended for shared pointer as a shared pointer has to create a control block for ref count, so calling new (creating object) then passing it to shared pointer to make that object again is inefficient.
- The ~std::make_shared<Type>();~ avoids this by creating both control block and object together once efficiently.
#+begin_src C++ :results output :exports both :includes <iostream>
  #include <memory>

  class Test{
  public:
    Test(){std::cout << "Test is Created" << std::endl;}
    ~Test(){std::cout << "Test is Destroyed" << std::endl;}
  };

  int main(){
    {
      std::shared_ptr<Test> test;
      {
        std::shared_ptr<Test> test1 = std::make_shared<Test>();
        test = test1;
      }
      std::cout << "None destroyed yet" << std::endl;
    }
    return 0;
  }
#+end_src

#+RESULTS:
: Test is Created
: None destroyed yet
: Test is Destroyed

**** Weak Pointer
- =weak_ptr= is used in case you want to hold a reference to an object, but you don't want the =shared_ptr= ref count to track it, thus unnecessarily keeping it alive.
#+begin_src C++ :results output :exports both :includes <iostream>
  #include <memory>

  class Test{
  public:
    Test(){std::cout << "Test is Created" << std::endl;}
    ~Test(){std::cout << "Test is Destroyed" << std::endl;}
  };

  int main(){
    {
      std::weak_ptr<Test> test;
      {
        std::shared_ptr<Test> test1 = std::make_shared<Test>();
        test = test1;
      }
      std::cout << "obj destroyed before weak ptr scope" << std::endl;
    }
    return 0;
  }
#+end_src

#+RESULTS:
: Test is Created
: Test is Destroyed
: obj destroyed before weak ptr scope

- =weak_ptr= doesnot guarentee if the obj is alive, it just stores a reference. So you can ask it if the obj is alive or already destroyed/dead.

*** Templates
- Template is a way to define a type that can be used to create multiple types.
- Basically the type is a placeholder that can be replaced with a different type.
- ~template <typename T>~ is the syntax for defining T, which can be used instead of Type in function declaration to get function template.
- A template does not actually *exist* yet, it is constructed when it gets used/called with a given type. So, an uncalled template function *can have* syntactic errors but compile fine.
- While calling a template function we can explicitly specify the type to be used. This is optional when compiler can deduce the type by itself(by return value or looking at arg passed) but necessary when the compiler can't do so.

#+begin_src C++ :results output :exports both :includes <iostream>
  template <typename T>
  // template <class T> // alternative keyword for typename is class
  void print(T t){
    std::cout << t << std::endl;
  }

  int main(){
    print(1);
    print<int>(1);
    print("Hello");
    print(1.2);
    return 0;
  }
#+end_src

#+RESULTS:
: 1
: 1
: Hello
: 1.2

- Templates are not just limited to types, and functions we can create entire classes with templates.
#+begin_src C++ :results output :exports both :includes <iostream>
  // template <int M>
  template <typename T, int N>
  class Array{
    T m_Array[N];
  public:
    int get_size() const{return N;}
  };

  int main(){
    Array<std::string, 50> a;
    std::cout << a.get_size() << std::endl;
    return 0;
  }

#+end_src

#+RESULTS:
: 50

- Eg, logging is common use where we want to log virtually every type without having to overload the function.
- Try to prefer overloading, because template open doors for everytype through it making it debugging nightmare
- Don't go and create your own mini language with it though, also called DSL. Don't.

*** Function pointers
- Code is data, function can be assigned variable, passed around as parameter, returned from a function, listed in an array etc.
- =function_pointer= is what enables this in languages like C/C++.
#+begin_src C++ :results output :exports both :includes <iostream>
  void hello(){
    std::cout << "hello world!" << std::endl;
  }

  int main(){
    auto function = hello; // or &hello (optional because of implicit conversion)
    std::cout << "Function 'hello' is at "<< function << std::endl;
    function();
  }
#+end_src

#+RESULTS:
: Function 'hello' is at1
: hello world!

- =auto= helps us to avoid explicit type declaration. But what is the actual type of func pointer?
- ~void(*name)();~ is the real type. This is usually defined once using typedef and used everywhere or just use auto.
#+begin_src C++ :results output :exports both :includes <iostream>
  void hello(){
    std::cout << "hello world!" << std::endl;
  }

  int main(){
    typedef void(*func_ptr)(); //args inside here();
    func_ptr function = hello; // or &hello (optional because of implicit conversion)
    std::cout << "Function 'hello' is at "<< function << std::endl;
    function();
  }
#+end_src

#+RESULTS:
: Function 'hello' is at 1
: hello world!

**** ForEach implementation
#+begin_src C++ :results output :exports both :includes <iostream>
  #include <vector>
  void print(int val){
    std::cout << val << std::endl;
  }

  void forEach(std::vector<int>& values, void(*func)(int)){
    for(int val: values){
      func(val);
    }
  }

  int main(){
    std::vector<int> values = {1,2,4};
    forEach(values, print);
    return 0;
  }
#+end_src

#+RESULTS:
: 1
: 2
: 4

*** Virtual Destructors
- You have a base class, you derive another class called 'derived' from that 'base' class.
- Now, with polymorphism you can assign a pointer of type 'base' to an object of 'derived'
- In such cases, Cpp calls destructor of only 'base' and doesnot call destructor of 'derived' when that ptr goes out of scope/dies.
- To ensure all the destructors in the tree are called, we use =virtual=
#+begin_src C++ :results output :exports both :includes <iostream>
  using namespace std;

  class base {
  public:
    base()
    { cout << "Constructing base\n"; }
    virtual ~base()
    { cout << "Destructing base\n"; }
  };

  class derived : public base {
  public:
    derived()
    { cout << "Constructing derived\n"; }
    ~derived()
    { cout << "Destructing derived\n"; }
  };

  int main()
  {
    derived *d = new derived();
    base *b = d;
    delete b;
  }
#+end_src

#+RESULTS:
: Constructing base
: Constructing derived
: Destructing derived
: Destructing base

#+begin_src C++ :results output :exports both :includes <iostream>
  using namespace std;

  class base {
  public:
    base()
    { cout << "Constructing base\n"; }
    virtual ~base()
    { cout << "Destructing base\n"; }
  };

  class derived : public base {
  public:
    derived()
    { cout << "Constructing derived\n"; }
    virtual ~derived()
    { cout << "Destructing derived\n"; }
  };

  class derivedmore : public derived{
  public:
    derivedmore()
    { cout << "Constructing derivedmore\n"; }
    ~derivedmore()
    { cout << "Destructing derivedmore\n"; }
  };

  int main()
  {
    derivedmore *d = new derivedmore();
    derived *b = d;
    delete b;
  }

#+end_src

#+RESULTS:
: Constructing base
: Constructing derived
: Constructing derivedmore
: Destructing derivedmore
: Destructing derived
: Destructing base

*** Exception Handling
- Example when =throw= is inside the =try= block
#+begin_src C++ :results output :exports both :includes <iostream>
  int main(){
    int a = 0;
    try{
      if(a!= 0){
        std::cout << "10/a = " << 10/a << std::endl;
      }else{
        throw(a);
      }
    }catch(int x){
      std::cout << "Error: x = " << x << std::endl;
    }
  }
#+end_src

#+RESULTS:
: Error: x = 0

- Example when exception is thrown by a =function= called inside a =try= block.
#+begin_src C++ :results output :exports both :includes <iostream>
  void func(int a){
    if(a!= 0){
      std::cout << "10/a = " << 10/a << std::endl;
    }else{
      throw(a);
    }
  }

  int main(){
    int a = 0;
    try{
      func(a);
    }catch(int x){
      std::cout << "Error: x = " << x << std::endl;
    }
  }
#+end_src

#+RESULTS:
: Error: x = 0

- Multiple catches and rethrowing an exception
#+begin_src C++ :results output :exports both :includes <iostream>
  using namespace std;

  void test(int x)
  {
    try
      {
        if (x==0) throw x;
        if (x==-1) throw 'x';
        if (x==1) throw 1.0;
        if (x==2) throw 3.0f;
      }
    catch (float x)
      {
        cout << "Caught an float exception x = " << x << endl;
        throw;
      }
    catch (...)
      {
        cout << "Caught an exception \n";
      }
  }
  int main()
  {
    test(-1);
    test(0);
    test(1);

    try{
      test(2);
    }catch(float){
        cout << "Catched the rethrown exception";
      }
    return 0;
  }
#+end_src

#+RESULTS:
: Caught an exception
: Caught an exception
: Caught an exception
: Caught an float exception x = 3
: Catched the rethrown exception

*** File Handling
#+begin_src shell :exports none
   echo "-- hello  is a file --\nHow are you\t there\n" > /tmp/cpp-hello-file.txt
#+end_src

#+RESULTS:

**** Extraction Operator
- The file handling functions are defined in the header ~<fstream>~.
- File can be read into a defined string through extraction operator, however remember the extraction operator only support words since it stops when encounter whitespace.
#+begin_src C++ :results output :exports both :includes <iostream>
  #import <fstream>
  using namespace std;
  int main(){
    ifstream fin;
    char str[100];
    fin.open("/tmp/cpp-hello-file.txt");
    while(!fin.eof()){ // or while(fin) also works
      fin >> str; // word by word
      cout << str << " "; // how to separate each word (through space)
    }
  }
#+end_src

#+RESULTS:
: -- hello is a file -- How are you there there

**** .get(char)
- ~fin.get~ is char by char getter of the file stream.
#+begin_src C++ :results output :exports both :includes <iostream>
  #import <fstream>

  using namespace std;

  int main(){
    ifstream fin;
    char str[100];
    char ch;
    fin.open("/tmp/cpp-hello-file.txt");
    while(!fin.eof()){ // or while(fin) also works
      fin.get(ch);
      cout<<ch;
    }
  }
#+end_src

#+RESULTS:
: -- hello  is a file --
: How are you	 there
:
:

**** .getline(toStr, size)
- ~getline(dest, size)~ can also be used.
#+begin_src C++ :results output :exports both :includes <iostream>
  #import <fstream>

  using namespace std;

  int main(){
    ifstream fin;
    char str[100];
    char ch;
    fin.open("/tmp/cpp-hello-file.txt");
    while(fin){ // or while(fin) also works
      fin.getline(str, 99);
      cout << str << "\n"; // how to separate each line (through newline)
    }
  }
#+end_src

#+RESULTS:
: -- hello  is a file --
: How are you	 there
:
:

**** Objects read write
- =read()= and =write()= function are available as well.
#+begin_src C++ :results output :exports both :includes <iostream>
  #include <fstream>

  class Test{
    int a = 4;
  public:
    void get_a(){std::cout << a << std::endl;}
  };

  int main(){
    Test t;

    std::ofstream fout;
    fout.open("/tmp/cpp-fout-class");
    fout.write((char*)&t, sizeof(Test));
    fout.close();

    Test t2;
    std::ifstream fin;
    fin.open("/tmp/cpp-fout-class");
    fin.read((char*)&t2, sizeof(Test));
    fin.close();
    t2.get_a();
  }
#+end_src

#+RESULTS:
: 4

**** Random Access in Files
*seekg* : ~seekg(bytes, ios::cur/beg/end)~
- Moves the file reading pointer forward and backward.
*seekp* ~seekp(bytes, ios::cur/beg/end)~
- Moves the writing pointer forward and backward.
*tellp* ~tellp()~
- Returns distance of writing pointer from beginnning in bytes.
*tellg* ~tellg()~
- Returns distance of writing pointer from beginnning in bytes.
#+begin_src C++ :results output :exports both :includes <iostream>
  #include <fstream>

  class Test{};

  int main(){
    Test t;
    std::ofstream fout;
    fout.open("/tmp/cpp-fout-class");
    fout.write((char*)&t, sizeof(Test));
    fout.write((char*)&t, sizeof(Test));
    int end = fout.tellp();
    fout.close();
    std::cout << "Wrote " << end/sizeof(Test) << " objects" <<std::endl;
  }

#+end_src

#+RESULTS:
: Wrote 2 objects
